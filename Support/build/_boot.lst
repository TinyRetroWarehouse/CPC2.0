ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 1.
Hexadecimal [16-Bits]



                              1 ; boot.asm
                              2 ;
                              3 ; Boot up assembly
                              4 ; Part of the CPC2 project: http://intelligenttoasters.blog
                              5 ; Copyright (C)2017  Intelligent.Toasters@gmail.com
                              6 ;
                              7 ; This program is free software; you can redistribute it and/or modify
                              8 ; it under the terms of the GNU General Public License as published by
                              9 ; the Free Software Foundation; either version 3 of the License, or
                             10 ; (at your option) any later version.
                             11 ;
                             12 ; This program is distributed in the hope that it will be useful,
                             13 ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                             14 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                             15 ; GNU General Public License for more details.
                             16 ;
                             17 ; You should have received a copy of the GNU General Public License
                             18 ; along with this program; if not, you can find a copy here:
                             19 ; https://www.gnu.org/licenses/gpl-3.0.en.html
                             20 ;
                             21 
                             22 	.module bootblk
                             23 
                             24 	.area _VECT0 (ABS)
   0000                      25 	.org	0x0000
                             26 
                             27 ;	ld sp,#0h0000	; Stack is top of memory
   0000 31 00 80      [10]   28 	ld sp,#0h8000	; Stack is before shared memory space
   0003 C3 00 00      [10]   29 	jp BOOTSYS
                             30 ;	jp debug
                             31 
                             32 	.area _VECT1 (ABS)
   0008                      33 	.org	0x0008
   0008 ED 4D         [14]   34 	reti
                             35 
                             36 	.area _VECT2 (ABS)
   0010                      37 	.org	0x0010
   0010 ED 4D         [14]   38 	reti
                             39 
                             40 	.area _VECT3 (ABS)
   0018                      41 	.org	0x0018
   0018 ED 4D         [14]   42 	reti
                             43 
                             44 	.area _VECT4 (ABS)
   0020                      45 	.org	0x0020
   0020 ED 4D         [14]   46 	reti
                             47 
                             48 	.area _VECT5 (ABS)
   0028                      49 	.org	0x0028
   0028 ED 4D         [14]   50 	reti
                             51 
                             52 	.area _VECT6 (ABS)
   0030                      53 	.org	0x0030
   0030 ED 4D         [14]   54 	reti
                             55 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 2.
Hexadecimal [16-Bits]



                             56 	.area _VECT7 (ABS)
   0038                      57 	.org	0x0038
   0038 ED 73 4D 00   [20]   58 	ld (#INT_SP), sp
   003C 31 65 00      [10]   59 	ld sp, #INT_STACK
   003F D9            [ 4]   60 	exx					; Fast swap
   0040 08            [ 4]   61 	ex af,af'
   0041 CD 00 00      [17]   62 	call _int_handler
   0044 08            [ 4]   63 	ex af,af'
   0045 D9            [ 4]   64 	exx					; Fast swap
   0046 ED 7B 4D 00   [20]   65 	ld sp, (#INT_SP)
   004A FB            [ 4]   66 	ei
   004B ED 4D         [14]   67 	reti
                             68 
                             69 ; Local stack for INT, 2 bytes to record SP and 16 stack entries
   004D                      70 INT_SP:
   004D                      71 	.ds		2
   004F                      72 	.ds		22
   0065                      73 INT_STACK:	; Stack starts here and works down
                             74 
                             75 	.area _VECT_NMI (ABS)
   0066                      76 	.org	0x0066
   0066 ED 73 7A 00   [20]   77 	ld (#NMI_SP), sp
   006A 31 8C 00      [10]   78 	ld sp, #NMI_STACK
   006D D9            [ 4]   79 	exx					; Fast swap
   006E 08            [ 4]   80 	ex af,af'
   006F CD 00 00      [17]   81 	call _nmi_handler
   0072 08            [ 4]   82 	ex af,af'
   0073 D9            [ 4]   83 	exx					; Fast swap
   0074 ED 7B 7A 00   [20]   84 	ld sp, (#NMI_SP)
   0078 ED 45         [14]   85 	retn
                             86 
                             87 ; Local stack for NMI, 2 bytes to record SP and 16 stack entries
   007A                      88 NMI_SP:
   007A                      89 	.ds		2
   007C                      90 	.ds		16
   008C                      91 NMI_STACK:	; Stack starts here and works down
                             92 
                             93 ; Used to move the start of the code section if the ABS sections expand
                     008C    94 _CODE_START = .
                             95 
                             96 ;
                             97 ; ==================================================================
                             98 ;
                             99 ;; Ordering of segments for the linker so that initializing vars works
                            100 	.area   _SYSTEM_CODE
                            101 
                            102 	.area   _GSINIT
                            103 
                            104 	.area   _INITIALIZER
                     0000   105 s__INITIALIZER = .
                            106 	.area	_END_INITIALIZER
                     0000   107 e__INITIALIZER = .
                            108 ;	.ds		256				; Ensure we're in a new page for write-protect
                            109 	.area	_DATA
                     0000   110 s__DATA = .
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 3.
Hexadecimal [16-Bits]



                            111 	.area	_INITIALIZED
                     0000   112 s__INITIALIZED = .
                            113 ;
                            114 ; ==================================================================
                            115 ;
                            116 	; Leave space for all of the ABS locations
                            117 	.area	_CODE
   0000                     118 	.ds		_CODE_START
                            119 ;
                            120 ; ==================================================================
                            121 ;
                            122 	.area   _GSINIT
                            123 ; Copy the initialized values to the working area
   0000                     124 gsinit:
   0000 21 00 00      [10]  125 	ld		hl, #e__INITIALIZER
   0003 11 00 00      [10]  126 	ld		de, #s__INITIALIZER
   0006 ED 52         [15]  127 	sbc		hl,de
                            128 ;	inc 	hl
   0008 E5            [11]  129 	push	hl
   0009 C1            [10]  130 	pop 	bc
                            131 	; Got length of initializer section
   000A 78            [ 4]  132 	ld      a, b
   000B B1            [ 4]  133 	or      a, c
   000C 28 08         [12]  134 	jr      Z, gsinit_next
   000E 11 00 00      [10]  135 	ld      de, #s__INITIALIZED
   0011 21 00 00      [10]  136 	ld      hl, #s__INITIALIZER
   0014 ED B0         [21]  137 	ldir
   0016                     138 gsinit_next:
   0016 C9            [10]  139 	ret
                            140 ;
                            141 ; ==================================================================
                            142 ;
                            143 	.area   _SYSTEM_CODE
                            144 
   0000                     145 BOOTSYS:
                            146 	; Write protect the memory
   0000 3E 00         [ 7]  147 	ld a,#(s__DATA>>8)
   0002 D3 50         [11]  148 	out(0x50),a				; Memory controller write protect boundary
                            149 
                            150 	; Now initialize
   0004 CD 15 00      [17]  151 	call CLRREG
   0007 ED 56         [ 8]  152 	im 1
   0009 CD 00 00      [17]  153 	call gsinit
   000C 0E 10         [ 7]  154 	ld c, #0x10	; Clear the interrupt register
   000E ED 78         [12]  155 	in a,(c)
                            156 
                            157 	; Start main process
                            158 ;	ei
   0010 CD 00 00      [17]  159 	call _main
   0013 18 EB         [12]  160 	jr #BOOTSYS
                            161 
                            162 ; Clear out all the registers so we're not pushing unknown values onto the stack (helps modelsim!)
   0015                     163 CLRREG:
   0015 21 00 00      [10]  164 	ld hl,#0
   0018 11 00 00      [10]  165 	ld de,#0
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 4.
Hexadecimal [16-Bits]



   001B 01 00 00      [10]  166 	ld bc,#0
   001E C5            [11]  167 	push bc
   001F F1            [10]  168 	pop af
   0020 D9            [ 4]  169 	exx
   0021 21 00 00      [10]  170 	ld hl,#0
   0024 11 00 00      [10]  171 	ld de,#0
   0027 01 00 00      [10]  172 	ld bc,#0
   002A C5            [11]  173 	push bc
   002B F1            [10]  174 	pop af
   002C DD 21 00 00   [14]  175 	ld ix,#0
   0030 FD 21 00 00   [14]  176 	ld iy,#0
   0034 D9            [ 4]  177 	exx
   0035 C9            [10]  178 	ret
                            179 
                            180 ; This is a native routine to do proper I/O
                            181 ; First parameter is address, second is data
   0036                     182 _OUT:
   0036 F5            [11]  183         push af
   0037 C5            [11]  184         push bc
   0038 DD E5         [15]  185         push ix
                            186         ; Add x params plus ret addr to the current stack pointer and we should be looking at the first parameter word
   003A DD 21 08 00   [14]  187         ld ix,#8        ; Add 5 word parameters plus the call return word
   003E DD 39         [15]  188         add ix,sp
   0040 DD 4E 00      [19]  189         ld c,0(ix)      ; Get the port
   0043 DD 46 01      [19]  190         ld b,1(ix)      ; and the data
   0046 ED 41         [12]  191         out (c),b       ; Send the data
   0048 DD E1         [14]  192         pop ix
   004A C1            [10]  193         pop bc
   004B F1            [10]  194         pop af
   004C C9            [10]  195         ret
                            196 
                            197 ; This is a native route to do proper I/O
                            198 ; First parameter is the port, returning data
   004D                     199 _IN:
   004D F5            [11]  200         push af
   004E C5            [11]  201         push bc
   004F DD E5         [15]  202         push ix
                            203 
   0051 DD 21 08 00   [14]  204         ld ix, #8
   0055 DD 39         [15]  205         add ix,sp       ; Get parameters off stack
                            206 
   0057 DD 4E 00      [19]  207         ld c,0(ix)      ; Get port #
   005A 06 FF         [ 7]  208         ld b,#0xff
   005C ED 78         [12]  209         in a,(c)        ; Read the port
   005E 6F            [ 4]  210         ld l,a          ; Returns a single character in l
                            211 
   005F DD E1         [14]  212         pop ix
   0061 C1            [10]  213         pop bc
   0062 F1            [10]  214         pop af
   0063 C9            [10]  215         ret
                            216 
                            217 ; This is a native route to do proper I/O
                            218 ; First parameter is the port, second is the buffer ptr, third is the count
   0064                     219 _OUTI:
   0064 F5            [11]  220         push af
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 5.
Hexadecimal [16-Bits]



   0065 C5            [11]  221         push bc
   0066 E5            [11]  222         push hl
   0067 DD E5         [15]  223         push ix
                            224         ; Add x params plus ret addr to the current stack pointer and we should be looking at the first parameter word
   0069 DD 21 0A 00   [14]  225         ld ix,	#10		; Skip over what we've just pushed onto the stack (inc the return address)
   006D DD 39         [15]  226         add ix,sp
   006F DD 4E 00      [19]  227         ld c,0(ix)      ; Get the port
   0072 DD 6E 01      [19]  228         ld l,1(ix)      ; and the data addr
   0075 DD 66 02      [19]  229         ld h,2(ix)      ; and the data addr
   0078 DD 46 03      [19]  230         ld b,3(ix)		; and the count
   007B ED B3         [21]  231         otir			; Send the data
   007D DD E1         [14]  232         pop ix
   007F E1            [10]  233         pop hl
   0080 C1            [10]  234         pop bc
   0081 F1            [10]  235         pop af
   0082 C9            [10]  236         ret
                            237 
                            238 ; This is a native route to do proper I/O
                            239 ; First parameter is the port, second is the buffer ptr, third is the count
   0083                     240 _INI:
   0083 F5            [11]  241         push af
   0084 C5            [11]  242         push bc
   0085 E5            [11]  243         push hl
   0086 DD E5         [15]  244         push ix
                            245         ; Add x params plus ret addr to the current stack pointer and we should be looking at the first parameter word
   0088 DD 21 0A 00   [14]  246         ld ix,	#10		; Skip over what we've just pushed onto the stack (inc the return address)
   008C DD 39         [15]  247         add ix,sp
   008E DD 4E 00      [19]  248         ld c,0(ix)      ; Get the port
   0091 DD 6E 01      [19]  249         ld l,1(ix)      ; and the data addr
   0094 DD 66 02      [19]  250         ld h,2(ix)      ; and the data addr
   0097 DD 46 03      [19]  251         ld b,3(ix)		; and the count
   009A ED B2         [21]  252         inir			; Get the data
   009C DD E1         [14]  253         pop ix
   009E E1            [10]  254         pop hl
   009F C1            [10]  255         pop bc
   00A0 F1            [10]  256         pop af
   00A1 C9            [10]  257         ret
                            258 
                            259 ; Native memset routine for performance
   00A2                     260 _memset:
   00A2 F5            [11]  261         push af
   00A3 C5            [11]  262         push bc
   00A4 D5            [11]  263         push de
   00A5 E5            [11]  264         push hl
   00A6 DD E5         [15]  265         push ix
                            266         ; Add x params plus ret addr to the current stack pointer and we should be looking at the first parameter word
   00A8 DD 21 0C 00   [14]  267         ld ix, #12		; Skip over what we've just pushed onto the stack (inc the return address)
   00AC DD 39         [15]  268         add ix,sp
   00AE DD 5E 00      [19]  269         ld e,0(ix)      ; Get the address
   00B1 DD 56 01      [19]  270         ld d,1(ix)
   00B4 DD 6E 00      [19]  271         ld l,0(ix)      ; Get the address again
   00B7 DD 66 01      [19]  272         ld h,1(ix)
   00BA DD 7E 02      [19]  273         ld a,2(ix)		; Value
   00BD DD 4E 03      [19]  274         ld c,3(ix)		; Count
   00C0 DD 46 04      [19]  275         ld b,4(ix)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 6.
Hexadecimal [16-Bits]



   00C3 12            [ 7]  276 		ld (de), a		; Set first byte
   00C4 13            [ 6]  277 		inc de
   00C5 0B            [ 6]  278 		dec bc			; Reduce BC by one (we did that byte already)
   00C6 78            [ 4]  279 		ld a,b			; Check it's not zero
   00C7 B1            [ 4]  280 		or c
   00C8 28 28         [12]  281 		jr z, mem_done
   00CA ED B0         [21]  282 		ldir			; Reset memory
   00CC 18 24         [12]  283 		jr mem_done
                            284 
                            285 ; Native memcpy routine for performance
   00CE                     286 _memcpy:
   00CE F5            [11]  287         push af
   00CF C5            [11]  288         push bc
   00D0 D5            [11]  289         push de
   00D1 E5            [11]  290         push hl
   00D2 DD E5         [15]  291         push ix
                            292         ; Add x params plus ret addr to the current stack pointer and we should be looking at the first parameter word
   00D4 DD 21 0C 00   [14]  293         ld ix, #12		; Skip over what we've just pushed onto the stack (inc the return address)
   00D8 DD 39         [15]  294         add ix,sp
   00DA DD 5E 00      [19]  295         ld e,0(ix)      ; Get the destination address
   00DD DD 56 01      [19]  296         ld d,1(ix)
   00E0 DD 6E 02      [19]  297         ld l,2(ix)      ; Get the source address
   00E3 DD 66 03      [19]  298         ld h,3(ix)
   00E6 DD 4E 04      [19]  299         ld c,4(ix)		; Count
   00E9 DD 46 05      [19]  300         ld b,5(ix)
   00EC 78            [ 4]  301 		ld a,b			; Check it's not zero
   00ED B1            [ 4]  302 		or c
   00EE 28 02         [12]  303 		jr z, mem_done
   00F0 ED B0         [21]  304 		ldir			; Reset memory
                            305 
   00F2                     306 mem_done:
   00F2 DD E1         [14]  307         pop ix
   00F4 E1            [10]  308         pop hl
   00F5 D1            [10]  309         pop de
   00F6 C1            [10]  310         pop bc
   00F7 F1            [10]  311         pop af
   00F8 C9            [10]  312         ret
                            313 
                            314 	.globl debug
   00F9                     315 debug:
   00F9 01 E0 03      [10]  316 		ld bc, #0x03e0
   00FC ED 41         [12]  317 		out (c),b
   00FE 00            [ 4]  318 		nop
   00FF 00            [ 4]  319 		nop
   0100                     320 debug1:
   0100 DB BE         [11]  321 		in a,(0xbe)
   0102 18 FC         [12]  322 		jr debug1
                            323 
                            324 ; Export/Import global functions
                            325 	.globl _main
                            326 	.globl _OUT
                            327 	.globl _OUTI
                            328 	.globl _IN
                            329 	.globl _INI
                            330 	.globl _memset
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180), page 7.
Hexadecimal [16-Bits]



                            331 	.globl _memcpy
                            332 	.globl _nmi_handler
                            333 	.globl _int_handler
